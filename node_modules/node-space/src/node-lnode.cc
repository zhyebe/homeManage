
#include <node.h>
#include <v8.h>
#include <node_buffer.h>
#include <node_object_wrap.h>

extern "C" {
  #include "engine.h"
  #include "tt_gate.h"
  #include <stdlib.h>
}

#define TUPLE_MSG_SIG  1258
#define TUPLE_ERR 0x00
#define TUPLE_GET 0x01
#define TUPLE_PUT 0x02
#define TUPLE_APD 0x03
#define TUPLE_VAL 0x04
#define TUPLE_DEL 0x05
#define TUPLE_MAK 0x06
#define TUPLE_UMK 0x07

using namespace node;
using namespace v8;

class lnode : public ObjectWrap
{
public:
  static void Init(Handle<Object> exports);
private:
  explicit lnode();
  ~lnode();

  static void New(const FunctionCallbackInfo<Value>& args);
  static void connect(const FunctionCallbackInfo<Value>& args);
  static void send(const FunctionCallbackInfo<Value>& args);
  static void publish(const FunctionCallbackInfo<Value>& args);
  static void subscribe(const FunctionCallbackInfo<Value>& args);
  static void unsubscribe(const FunctionCallbackInfo<Value>& args);

  static void pollonce(const FunctionCallbackInfo<Value>& args);
  static void get_E(const FunctionCallbackInfo<Value>& args);
  static void tuple_get(const FunctionCallbackInfo<Value>& args);
  static void tuple_put(const FunctionCallbackInfo<Value>& args);
  static void tuple_to(const FunctionCallbackInfo<Value>& args);
  static void tuple_apd(const FunctionCallbackInfo<Value>& args);
  static void tuple_del(const FunctionCallbackInfo<Value>& args);
  static void tuple_mak(const FunctionCallbackInfo<Value>& args);
  static void tuple_umk(const FunctionCallbackInfo<Value>& args);

  static Persistent<Function> constructor;
  void* E;
  void* hgate;
  char nodeid[128];
  char gateid[128];
public:
  Persistent<Function> recv_cb;
  Persistent<Function> connected_cb;
  Persistent<Function> disconnected_cb;
};

Persistent<Function> lnode::constructor;

void lnode_recv(void* ud_, const char* fromid_, const char* key_, int sig_, char* data_, int siz_);
void lnode_identer(void* ud_, const char* id_);
void lnode_idleave(void* ud_, const char* id_);
void print_hex(uint8_t* data_, int siz_, int len_);

lnode::lnode()
{
}

lnode::~lnode()
{
}

void lnode::Init(Handle<Object> exports)
{
  Isolate* isolate = Isolate::GetCurrent();
  //Prepare constructor template
  Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);
  tpl->SetClassName(String::NewFromUtf8(isolate, "lnode"));
  tpl->InstanceTemplate()->SetInternalFieldCount(1);
  // Prototype
  NODE_SET_PROTOTYPE_METHOD(tpl, "get_E", get_E);
  NODE_SET_PROTOTYPE_METHOD(tpl, "pollonce", pollonce);
  NODE_SET_PROTOTYPE_METHOD(tpl, "connect", connect);
  NODE_SET_PROTOTYPE_METHOD(tpl, "send", send);
  NODE_SET_PROTOTYPE_METHOD(tpl, "publish", publish);
  NODE_SET_PROTOTYPE_METHOD(tpl, "subscribe", subscribe);
  NODE_SET_PROTOTYPE_METHOD(tpl, "unsubscribe", unsubscribe);

  NODE_SET_PROTOTYPE_METHOD(tpl, "tuple_get", tuple_get);
  NODE_SET_PROTOTYPE_METHOD(tpl, "tuple_put", tuple_put);
  NODE_SET_PROTOTYPE_METHOD(tpl, "tuple_to", tuple_to);
  NODE_SET_PROTOTYPE_METHOD(tpl, "tuple_apd", tuple_apd);
  NODE_SET_PROTOTYPE_METHOD(tpl, "tuple_del", tuple_del);
  NODE_SET_PROTOTYPE_METHOD(tpl, "tuple_mak", tuple_mak);
  NODE_SET_PROTOTYPE_METHOD(tpl, "tuple_umk", tuple_umk);

  constructor.Reset(isolate, tpl->GetFunction());
  exports->Set(String::NewFromUtf8(isolate, "createClient"), tpl->GetFunction());
}

void lnode::New(const FunctionCallbackInfo<Value>& args)
{
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);

  if (args.IsConstructCall()) {
    // Invoked as constructor: 'new lnode(...)'
    lnode* _obj = new lnode();
    _obj->Wrap(args.This());

    Local<String> _gateid = Local<String>::Cast(args[0]);
    char* _gateid1 = (char*)malloc(_gateid->Length());
    _gateid->WriteUtf8(_gateid1);
    strcpy(_obj->gateid, _gateid1);
    _obj->recv_cb.Reset(isolate, Local<Function>::Cast(args[1]));
    _obj->connected_cb.Reset(isolate, Local<Function>::Cast(args[2]));
    _obj->disconnected_cb.Reset(isolate, Local<Function>::Cast(args[3]));
    _obj->E = engine_init(0);
    engine_initsocket(_obj->E);
    engine_start(_obj->E);
    _obj->hgate = ttgate_new(_obj->E, _gateid1);
    ttgate_registerrecv(_obj->hgate, _obj, lnode_recv);
    ttgate_registeridenter(_obj->hgate, _obj, lnode_identer);
    ttgate_registeridleave(_obj->hgate, _obj, lnode_idleave);

    args.GetReturnValue().Set(args.This());
  }
  else {
    // Invoked as plain function 'lnode(...)', turn into construct all.
    const int argc = 1;
    Local<Value> argv[argc] = {args[0]};
    Local<Function> cons = Local<Function>::New(isolate, constructor);
    args.GetReturnValue().Set(cons->NewInstance(argc, argv));
  }
}

void lnode::tuple_get(const FunctionCallbackInfo<Value>& args)
{
  //Isolate* isolate = Isolate::GetCurrent();
  lnode* _obj = ObjectWrap::Unwrap<lnode>(args.Holder());
  char _key[128];
  Local<String>::Cast(args[0])->WriteUtf8(_key);

  int _len = strlen(_key) + 2 + strlen(_obj->gateid) + 1;
  char* _buffer = (char*)malloc(_len);
  _buffer[0] = (char)TUPLE_GET;
  strcpy(_buffer + 1, _key);
  strcpy(_buffer + 1 + strlen(_key) + 1, _obj->gateid);
  printf("tuple get %s %s\n", _key, _obj->gateid);
  ttgate_send(_obj->hgate, _obj->nodeid, _key, TUPLE_MSG_SIG, _buffer, _len);
  free(_buffer);
}

void lnode::tuple_put(const FunctionCallbackInfo<Value>& args)
{
  lnode* _obj = ObjectWrap::Unwrap<lnode>(args.Holder());
  char _key[128];
  Local<String>::Cast(args[0])->WriteUtf8(_key);
  Local<Object> data_obj = args[1]->ToObject();
  int _len = Buffer::Length(data_obj);
  char* _data = Buffer::Data(data_obj);
  //int _len = Local<String>::Cast(args[1])->Length();
  char* _buffer = (char*)malloc(strlen(_key) + 2 + _len);
  _buffer[0] = (char)TUPLE_PUT;
  strcpy(_buffer + 1, _key);
  memcpy(_buffer + 1 + strlen(_key) + 1, _data, _len);
  //Local<String>::Cast(args[1])->WriteOneByte((uint8_t*)(_buffer + strlen(_key) + 2));

  ttgate_send(_obj->hgate, _obj->nodeid, _key, TUPLE_MSG_SIG, _buffer, strlen(_key) + 2 + _len);
  free(_buffer);
}

void lnode::tuple_to(const FunctionCallbackInfo<Value>& args)
{
  lnode* _obj = ObjectWrap::Unwrap<lnode>(args.Holder());
  char _to[128];
  Local<String>::Cast(args[0])->WriteUtf8(_to);
  char _key[128];
  Local<String>::Cast(args[1])->WriteUtf8(_key);
  Local<Object> _data_obj = args[2]->ToObject();
  int _len = Buffer::Length(_data_obj);
  char* _data = Buffer::Data(_data_obj);
  //int _len = Local<String>::Cast(args[1])->Length();
  char* _buffer = (char*)malloc(strlen(_key) + 2 + _len);
  _buffer[0] = (char)TUPLE_VAL;
  strcpy(_buffer + 1, _key);
  memcpy(_buffer + 1 + strlen(_key) + 1, _data, _len);
  //Local<String>::Cast(args[2])->WriteOneByte((uint8_t*)(_buffer + strlen(_key) + 2));
  ttgate_send(_obj->hgate, _to, _key, TUPLE_MSG_SIG, _buffer, strlen(_key) + 2 + _len);
  free(_buffer);
}

void lnode::tuple_apd(const FunctionCallbackInfo<Value>& args)
{
  lnode* _obj = ObjectWrap::Unwrap<lnode>(args.Holder());
  char _key[128];
  Local<String>::Cast(args[0])->WriteUtf8(_key);
  //int _len = Local<String>::Cast(args[1])->Length();
  Local<Object> _data_obj = args[1]->ToObject();
  int _len = Buffer::Length(_data_obj);
  char* _data = Buffer::Data(_data_obj);
  char* _buffer = (char*)malloc(strlen(_key) + 2 + _len);
  _buffer[0] = (char)TUPLE_APD;
  strcpy(_buffer + 1, _key);
  memcpy(_buffer + 1 + strlen(_key) + 1, _data, _len);
  //Local<String>::Cast(args[1])->WriteOneByte((uint8_t*)(_buffer + strlen(_key) + 2));

  ttgate_send(_obj->hgate, _obj->nodeid, _key, TUPLE_MSG_SIG, _buffer, strlen(_key) + 2 + _len);
  free(_buffer);
}

void lnode::tuple_del(const FunctionCallbackInfo<Value>& args)
{
  lnode* _obj = ObjectWrap::Unwrap<lnode>(args.Holder());
  char _key[128];
  Local<String>::Cast(args[0])->WriteUtf8(_key);
  char* _buffer = (char*)malloc(strlen(_key) + 2);
  _buffer[0] = (char)TUPLE_DEL;
  strcpy(_buffer + 1, _key);
  ttgate_send(_obj->hgate, _obj->nodeid, _key, TUPLE_MSG_SIG, _buffer, strlen(_key) + 2);
  free(_buffer);
}

void lnode::tuple_mak(const FunctionCallbackInfo<Value>& args)
{
  lnode* _obj = ObjectWrap::Unwrap<lnode>(args.Holder());
  char _topic[128];
  Local<String>::Cast(args[0])->WriteUtf8(_topic);
  char _pattern[128];
  Local<String>::Cast(args[1])->WriteUtf8(_pattern);
  char* _buffer = (char*)malloc(strlen(_topic) + 2 + strlen(_pattern) + 1);
  _buffer[0] = (char)TUPLE_MAK;
  strcpy(_buffer + 1, _topic);
  strcpy(_buffer + 1 + strlen(_topic) + 1, _pattern);
  ttgate_send(_obj->hgate, _obj->nodeid, _topic, TUPLE_MSG_SIG, _buffer, strlen(_topic) + 2 + strlen(_pattern) + 1);
  free(_buffer);
}

void lnode::tuple_umk(const FunctionCallbackInfo<Value>& args)
{
  lnode* _obj = ObjectWrap::Unwrap<lnode>(args.Holder());
  char _topic[128];
  Local<String>::Cast(args[0])->WriteUtf8(_topic);
  char _pattern[128];
  Local<String>::Cast(args[1])->WriteUtf8(_pattern);
  char* _buffer = (char*)malloc(strlen(_topic) + 2 + strlen(_pattern) + 1);
  _buffer[0] = (char)TUPLE_MAK;
  strcpy(_buffer + 1, _topic);
  strcpy(_buffer + 1 + strlen(_topic) + 1, _pattern);
  ttgate_send(_obj->hgate, _obj->nodeid, _topic, TUPLE_MSG_SIG, _buffer, strlen(_topic) + 2 + strlen(_pattern) + 1);
  free(_buffer);
}

void lnode::pollonce(const FunctionCallbackInfo<Value>& args)
{
  //Isolate* isolate = Isolate::GetCurrent();
  lnode* _obj = ObjectWrap::Unwrap<lnode>(args.Holder());
  engine_pollonce(_obj->E, 10);
}

void lnode::get_E(const FunctionCallbackInfo<Value>& args) {
  lnode* _obj = ObjectWrap::Unwrap<lnode>(args.Holder());
  args.GetReturnValue().Set(Number::New(Isolate::GetCurrent(), (uint64_t)_obj->E));
}

void lnode::connect(const FunctionCallbackInfo<Value>& args)
{
  //Isolate* isolate = Isolate::GetCurrent();
  //HandleScope scope(isolate);
  lnode* _obj = ObjectWrap::Unwrap<lnode>(args.Holder());
  char _addr[32];
  char _nodeid[128];
  Local<String>::Cast(args[0])->WriteUtf8(_addr);
  Local<String>::Cast(args[1])->WriteUtf8(_nodeid);
  strcpy(_obj->nodeid, _nodeid);
  ttgate_connect(_obj->hgate, _addr, _nodeid);
}

void lnode::send(const FunctionCallbackInfo<Value>& args)
{
  //Isolate* isolate = Isolate::GetCurrent();
  lnode* _obj = ObjectWrap::Unwrap<lnode>(args.Holder());

  char _key[128];
  Local<String>::Cast(args[0])->WriteUtf8(_key);
  int _sig = args[1]->Int32Value();
  int _size = Local<String>::Cast(args[0])->Length();
  uint8_t* _data = (uint8_t*)malloc(_size);
  Local<String>::Cast(args[2])->WriteOneByte(_data);

  ttgate_send(_obj->hgate, (const char*)_obj->nodeid, (const char*)_key, _sig, (char*)_data, _size);
}

void lnode::publish(const FunctionCallbackInfo<Value>& args)
{
  //Isolate* isolate = Isolate::GetCurrent();
  lnode* _obj = ObjectWrap::Unwrap<lnode>(args.Holder());

  char _topic[128];
  Local<String>::Cast(args[0])->WriteUtf8(_topic);
  int _sig = args[1]->Int32Value();
  int _size = Local<String>::Cast(args[0])->Length();
  uint8_t* _data = (uint8_t*)malloc(_size);
  Local<String>::Cast(args[2])->WriteOneByte(_data);

  ttgate_send(_obj->hgate, (const char*)_obj->nodeid, (const char*)_topic, _sig, (char*)_data, _size);
}

void lnode::subscribe(const FunctionCallbackInfo<Value>& args)
{
  //Isolate* isolate = Isolate::GetCurrent();
  lnode* _obj = ObjectWrap::Unwrap<lnode>(args.Holder());

  char _topic[128];
  Local<String>::Cast(args[0])->WriteUtf8(_topic);

  ttgate_subscribe(_obj->hgate, (const char*)_obj->nodeid, (const char*)_topic);
}

void lnode::unsubscribe(const FunctionCallbackInfo<Value>& args)
{
  //Isolate* isolate = Isolate::GetCurrent();
  lnode* _obj = ObjectWrap::Unwrap<lnode>(args.Holder());

  char _topic[128];
  Local<String>::Cast(args[0])->WriteUtf8(_topic);

  ttgate_unsubscribe(_obj->hgate, (const char*)_obj->nodeid, (const char*)_topic);
}

void lnode_recv(void* ud_, const char* fromid_, const char* key_, int sig_, char* data_, int siz_)
{
  Isolate* isolate = Isolate::GetCurrent();

  printf("lnode recv %d %d %s\n", sig_, siz_, key_);
  if (sig_ != TUPLE_MSG_SIG) return;

  lnode* _gate = (lnode*)ud_;
  Local<Function> recv_cb = Local<Function>::New(isolate, _gate->recv_cb);

  Local<String> _key = String::NewFromUtf8(isolate, data_ + 1);
  uint8_t* _p = (uint8_t*)data_ + 1;
  for (; _p < (uint8_t*)(data_ + siz_); _p ++) {
    if (*_p == 0x00) break;
  }
  //Local<String> _data = String::NewFromOneByte(isolate, _p + 1, String::kNormalString, siz_ - (_p - (uint8_t*)data_) - 1);
  char* _buf = (char*)(_p + 1);
  int _size = siz_ - (_p - (uint8_t*)data_) - 1;
  //Local<Object> _data = NanNewBufferHandle(_buf, _size);

  if (_size <= 0) {
    const unsigned argc = 2;
    Local<Value> argv[argc];
    argv[0] = _key;
    argv[1] = Number::New(isolate, sig_);
    recv_cb->Call(isolate->GetCurrentContext()->Global(), argc, argv);
  }
  else {
    Local<Object> _data;
    MaybeLocal<Object> _datam = Buffer::Copy(isolate, _buf, _size);
    bool _isvalid = _datam.ToLocal(&_data);

    const unsigned argc = 3;
    Local<Value> argv[argc];// = {_key, _data};
    argv[0] = _key;
    argv[1] = Number::New(isolate, sig_);
    argv[2] = _data;
    recv_cb->Call(isolate->GetCurrentContext()->Global(), argc, argv);
  }
}

void lnode_identer(void* ud_, const char* id_)
{
  printf("lnode identer %s\n", id_);
  Isolate* isolate = Isolate::GetCurrent();
  lnode* _gate = (lnode*)ud_;
  Local<Function> connected_cb = Local<Function>::New(isolate, _gate->connected_cb);
  connected_cb->Call(isolate->GetCurrentContext()->Global(), 0, NULL);
}

void lnode_idleave(void* ud_, const char* id_)
{
  printf("lnode idleave %s\n", id_);
  Isolate* isolate = Isolate::GetCurrent();
  lnode* _gate = (lnode*)ud_;
  Local<Function> disconnected_cb = Local<Function>::New(isolate, _gate->disconnected_cb);
  disconnected_cb->Call(isolate->GetCurrentContext()->Global(), 0, NULL);
}

void print_hex(uint8_t* data_, int siz_, int len_)
{
  int _len = siz_ > len_ ? len_ : siz_;
  int i;
  for (i = 0; i < _len; i ++) {
    printf("%02x ", data_[i]);
  }
  printf("\n");
}

void InitAll(Handle<Object> exports)
{
  //NODE_SET_METHOD(exports, "lnode", lnode_new);
  lnode::Init(exports);
}

NODE_MODULE(lnode, InitAll);
