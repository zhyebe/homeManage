
var bindings = require('bindings');
var lnode = require('bindings')('lnode.node');
var protobuf = require('node-protobuf');
var _ = require('underscore');
var crypto = require('crypto');
var thenjs = require('thenjs');
var fs = require('fs');

//var lnodeClient = undefined;

function Model(options, lnodeClient) {
  this.lnodeClient = lnodeClient;

  this.handles = [];
  if (options.id) {
    this._id = options.id;
  }
  if (!options.desc) {
    //throw Error('must has protobuf desc');
  }
  this.desc = options.desc;
  if (!options.schema) {
    //throw Error('mush has schema');
  }
  this.schema = options.schema;
  if (this.desc) {
    // console.log(this.schema);
    // var _schemaPath = bindings.getRoot(bindings.getFileName());
    // //console.log(_schemaPath);
    // var desc = fs.readFileSync(_schemaPath + '/descriptor.desc');
    //
    // try {
    //   var pb = new protobuf(desc);
    //   console.log(pb.info());
    //   var obj = pb.parse(this.desc, 'google.protobuf.FileDescriptorSet');
    //   console.log(obj);
    // }
    // catch (e) {
    //   console.log(e);
    // }
    this.pb = new protobuf(this.desc);

  }
  if (this.desc) {
    this.data = _.omit(options, ['desc', 'schema']);
  }
  else {
    this.data = null;
  }
}

Model.prototype.set = function(key, data) {
  if (_.isString(key)) {
    this.data[key] = data;
  }
  else if (_.isObject(key)) {
    if (this.pb) {
      _.extend(this.data, key);
    }
    else {
      this.data = key;
    }
  }
  else {
    throw Error("model type error");
  }
}

Model.prototype.id = function() {
  return this._id;
}

Model.prototype.get = function(key) {
  return this.data[key];
}

Model.prototype.toJSON = function() {
  return this.data;
}

Model.prototype.fetch = function(callback, context) {
  if (callback) {
    this.on(callback, context, true);
  }
  this.lnodeClient.tuple_get(this._id);
  if (callback) {
    var _this = this;
    this.timer = setTimeout(function() {
      callback.call(context,  new Error('Model fetch timeout.'), _this);
    }, 5000);
  }
}

Model.prototype.refer = function() {
  try {
    if (this.pb) {
      var _buf = this.pb.serialize(this.data, this.schema);
      this.lnodeClient.tuple_put(this._id, _buf);
    }
    else {
      this.lnodeClient.tuple_put(this._id, this.data);
    }
  }
  catch (e) {
    console.log(e);
  }
}

Model.prototype.process = function(data) {

  try {
    if (this.timer) {
      clearTimeout(this.timer)
      this.timer = undefined;
    }
    if (this.pb) {
      if (data) {
        var newObj = this.pb.parse(data, this.schema);
        this.newData = newObj;
        _.extend(this.data, newObj);
      }
      else {
        this.newData = null;
        //this.data = null;
      }
    }
    else {
      this.newData = data;
      this.data = data;
    }
    this.trigger();
  }
  catch (e){
    console.log("3333333333333333");
    console.log(e);
  }
}

Model.prototype.on = function(callback, context, once) {
  var handle = _.find(this.handles, function(item) {
    if (item.callback == callback && item.context == context) {
      return true;
    }
    return false;
  });

  if (handle) return;
  if (once == undefined) once = false;

  handle = {callback: callback, context: context, once: once};
  this.handles.push(handle);
}

Model.prototype.off = function(callback, context) {
  var handle = _.find(this.handles, function(item) {
    if (item.callback == callback && item.context == context) {
      return true;
    }
    return false;
  });

  if (handle) {
    var index = _.indexOf(this.handles, handle);
    this.handles.splice(index, 1);
  }
}

Model.prototype.trigger = function() {
  var _this = this;

  _.each(this.handles, function(handle) {
    handle.callback.call(handle.context, _this.newData ? null : new Error('Empty'), _this);
  });
  this.handles = _.filter(this.handles, function(item) {
    return !item.once;
  });
}

function Space(options) {
  this.models = {};
  this.handles = {};
  this.reconnectHandle = null;
  this.configure(options);
  this.sublist = [];
}

Space.prototype.configure = function(options) {

  if (!options.nodeid || !options.nodeaddr) {
    throw Error('space configure miss nodeid or nodeaddr.');
  }
  if (!options.clientid) {
    var buf = crypto.randomBytes(8);
    options.clientid = options.nodeid + '.' + buf.toString('hex');
  }
  this._options = options;
  this.connected = false;
  var _this = this;

  this.lnodeClient = new lnode.createClient(options.clientid,
    function(key, sig, data) {
      if (data) {
        console.log('node recv ' + key + ' ' + data.length);
      }
      else {
        console.log('node recv ' + key + ' 0');
      }

      var model = _this.models[key];
      if (model) {
        model.process(data);
      }
      // else {
      //   var schema = _this.findSchema(key);
      //   if (schema) {
      //     console.log(schema);
      //     _this.preset(key, schema, function(err, model) {
      //       if (err) {
      //         console.log(err);
      //       }
      //       else {
      //         model.process(data);
      //         _.each(_this.handles['newmodel'], function(handle) {
      //           handle.callback.call(handle.context, model);
      //         });
      //       }
      //     });
      //   }
      // }

    },
    function() {
      console.log('node connected.');
      _this.connected = true;
      if (_this.reconnectHandle) {
        clearInterval(_this.reconnectHandle);
        _this.reconnectHandle = null;
      }

      var key = _this._options.nodeid + '.schemapattern';
      thenjs(function(cont) {
        var _schemaPath = bindings.getRoot(bindings.getFileName());
        _this.preset(key, fs.readFileSync(_schemaPath + '/SchemaPattern.desc'), function(err, model) {
          if (err) {
            cont(err);
          }
          else {
            cont(null, model);
          }
        });
      })
      .then(function(cont, result) {
        result.fetch(function(err, model) {
          if (err) {
            console.log(err);
            cont(err);
          }
          else {
            console.log(model.toJSON());
            cont(null, model);
          }

        });
      })
      .fin(function(cont, err, result) {
        if (err) {
          console.log(err);
        }

        _.each(_this.handles['online'], function(handle) {
          handle.callback.call(handle.context);
        });
      });
    },
    function() {
      console.log('node disconnected');
      _this.connected = false;

      _.each(_this.handles['offline'], function(handle) {
        handle.callback.call(handle.context);
      });

      if (!_this.reconnectHandle) {
        _this.reconnectHandle = setInterval(function() {
          _this.lnodeClient.connect(_this._options.nodeaddr, _this._options.nodeid);
          }, 20000);
      }
    }
  );

  this.timerHandle = setInterval(function() {
    _this.lnodeClient.pollonce();
  }, 10);
}

Space.prototype.connect = function()
{
  this.lnodeClient.connect(this._options.nodeaddr,
                      this._options.nodeid);
}

Space.prototype.getE = function() {
  return this.lnodeClient.get_E();
}

Space.prototype.options = function() {
  return this._options;
}

Space.prototype.on = function(event, callback, context, once) {
  if (!this.handles[event]) {
    this.handles[event] = [];
  }
  var handle = _.find(this.handles[event], function(item) {
    if (item.callback == callback && item.context == context) {
      return true;
    }
    return false;
  });
  if (handle) return;
  if (once == undefined) once = false;

  handle = {callback: callback, context: context, once: once};
  this.handles[event].push(handle);
}

Space.prototype.off = function(event, callback, context) {
  if (!this.handles[event]) return;

  var handle = _.find(this.handles[event], function(item) {
    if (item.callback == callback && item.context == context) {
      return true;
    }
    return false;
  });

  if (handle) {
    var index = _.indexOf(this.handles[event], handle);
    this.handles[event].splice(index, 1);
  }
}

Space.prototype.offAll = function(callback, context) {

  _.each(this.models, function(item) {
    item.off(callback, context);
  });
}

Space.prototype.preset = function(id, descriptor, callback) {
  var model = this.models[id];
  if (model) {
    callback(null, model);
  }
  if (!descriptor) {
    model = new Model({id: id}, this.lnodeClient);
    this.models[id] = model;
    callback(null, model);
    return;
  }
  var _this = this;
  if (typeof(descriptor) == 'string') {

    var key = _this._options.nodeid + '.proto.' + descriptor;

    thenjs(function(cont) {
      var model = _this.find(key);
      if (!model || !model.toJSON()) {

        if (!model) {
          model = new Model({id: key}, _this.lnodeClient);
          _this.models[key] = model;
        }
        model.fetch(function(err, model) {
          if (err) {
            cont(new Error('No Schema'));
          }
          else {
            cont(null, model);
            if (!_this.models[key]) {
              _this.models[key] = model;
            }
          }
        });
      }
      else {
        cont(null, model);
      }
    })
    .then(function(cont, result) {
      var descBuf = result.toJSON();
      var model = new Model({id: id,
                             schema: _this.schema(descBuf),
                             desc: descBuf}, _this.lnodeClient);

      if (_this.models[id]) {
        cont(null, _this.models[id]);
      }
      else {
        _this.models[id] = model;
        cont(null, model);
      }
    })
    .fin(function(cont, err, result) {

      callback(err, result);
    });
  }
  else if (typeof(descriptor) == 'object') {
    var resultModel = _this.find(id);
    if (!resultModel) {
      resultModel = new Model({id: id,
                               schema: _this.schema(descriptor),
                               desc: descriptor}, _this.lnodeClient);
      _this.models[id] = resultModel;
      callback(null, resultModel);
    }
    else {
      callback(null, resultModel);
    }
  }
  else {
    callback(Error('descriptor invalid.'));
  }
}

Space.prototype.find = function(id) {
  return this.models[id];
}

Space.prototype.remove = function(id) {
  this.models[id] = null;
}

Space.prototype.get = function(key, result) {

  var schema = this.findSchema(key);
  if (!schema) {
    result(null, new Error('no schema!'));
    return;
  }
  var _this = this;
  thenjs(function(cont) {
    var model = _this.find(key);
    if (!model) {
      _this.preset(key, schema, function(err, model) {
        if (err) {
          cont(new Error('schema failed.'));
        }
        else {
          cont(null, model);
        }
      });
    }
    else {
      cont(null, model);
    }
  })
  .then(function(cont, model) {
    model.fetch(function(err, model) {
      cont(err, model);
    });
  })
  .fin(function(cont, err, model) {
    if (err) {
      result(null, err);
    }
    else {
      result(model);
    }
  });
}

Space.prototype.put = function(key, value, result) {

  var _this = this;
  thenjs(function(cont) {
    var schema = _this.findSchema(key);
    if (!schema) {
      cont(new Error('No Schema.'));
    }
    else {
      var model = _this.find(key);
      if (!model) {
        _this.preset(key, schema, function(err, model) {
          if (err) {
            cont(err);
          }
          else {
            cont(null, model);
          }
        });
      }
      else {
        cont(null, model);
      }
    }
  })
  .then(function(cont, model) {
    model.set(value);
    model.refer();
    cont(null, model);
  })
  .fin(function(cont, err, model) {
    if (err) {
      result(null, err);
    }
    else {
      result(model);
    }
  });

  // console.log('put ' + key);
  // try {
  //   var model = this.models[key];
  //   if (!model) {
  //     throw Error('model not been set');
  //   }
  //   this.lnodeClient.tuple_put(key, value);
  // }
  // catch (e) {
  //   console.log(e);
  // }
}

Space.prototype.del = function(key, result) {
  this.lnodeClient.tuple_del(key);
}

Space.prototype.mak = function(topic, pattern, result) {
  this.lnodeClient.tuple_mak(topic, pattern);
}

Space.prototype.umk = function(topic, pattern, result) {

  this.lnodeClient.tuple_umk(topic, pattern);
}

Space.prototype.subscribe = function(topic) {

  this.lnodeClient.subscribe(topic);
}

Space.prototype.unsubscribe = function(topic) {
  this.lnodeClient.unsubscribe(topic);
}

Space.prototype.schema = function(buf) {
  var pb = new protobuf(buf);
  var info = pb.info();
  return info[info.length - 1];
}

Space.prototype.findSchema = function(key) {
  var schemaPatternModel = this.find(this._options.nodeid + '.schemapattern');
  if (!schemaPatternModel) return null;

  var entries = schemaPatternModel.get('entries');

  var i;
  for (i = 0; i < entries.length; i ++) {
    if (key.match(entries[i].pattern)) {
      return entries[i].schema;
    }
  }
  return null;
}

Space.prototype.addSchema = function(key, descriptor, callback) {

  var schema = this.schema(descriptor);
  if (!key) {
    key = this._options.nodeid + '.proto.' + schema;
  }
  var _this = this;
  thenjs(function(cont) {
    var protoModel = _this.find(key);
    if (!protoModel) {
      _this.preset(key, null, function(err, model) {
        if (err) {
          cont(err);
        }
        else {
          cont(null, model);
        }
      })
    }
    else {
      cont(null, protoModel);
    }
  })
  .then(function(cont, model) {
    model.set(descriptor);
    model.refer();
    cont(null, model);
  })
  .fin(function(cont, err, result) {
    if (callback) callback(result, err);
  });
}


module.exports = Space;
